import java.util.*;

public class OptimalPageReplacement {
    public static void main(String[] args) {
        int[] pages = {2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5, 2}; // given reference string
        int frames = 3;  // number of frames
        simulateOptimal(pages, frames);
    }

    public static void simulateOptimal(int[] pages, int frames) {
        List<Integer> memory = new ArrayList<>(frames);
        int pageFaults = 0;

        System.out.println("Page Reference String: " + Arrays.toString(pages));
        System.out.println("Number of Frames: " + frames);
        System.out.println("\nPage\tFrames\t\tPage Fault");

        for (int i = 0; i < pages.length; i++) {
            int page = pages[i];

            // If page already present → no fault
            if (memory.contains(page)) {
                System.out.println(page + "\t" + memory + "\t\tNo");
                continue;
            }

            // Page fault occurs
            pageFaults++;

            // If space available → add directly
            if (memory.size() < frames) {
                memory.add(page);
            } else {
                // Find page to replace (farthest in future)
                int indexToReplace = findFarthest(memory, pages, i + 1);
                memory.set(indexToReplace, page);
            }

            System.out.println(page + "\t" + memory + "\t\tYes");
        }

        System.out.println("\nTotal Page Faults: " + pageFaults);
    }

    // Function to find the page to replace using Optimal policy
    private static int findFarthest(List<Integer> memory, int[] pages, int startIndex) {
        int farthest = -1;
        int indexToReplace = -1;

        for (int i = 0; i < memory.size(); i++) {
            int page = memory.get(i);
            int nextUse = Integer.MAX_VALUE;

            // Find next use of this page
            for (int j = startIndex; j < pages.length; j++) {
                if (pages[j] == page) {
                    nextUse = j;
                    break;
                }
            }

            // If page not used again → replace this one
            if (nextUse == Integer.MAX_VALUE) {
                return i;
            }

            // Track page used farthest in future
            if (nextUse > farthest) {
                farthest = nextUse;
                indexToReplace = i;
            }
        }

        return indexToReplace;
    }
}
